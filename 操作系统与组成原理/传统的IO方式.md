# 传统的IO方式

基于传统的IO方式，底层实际上是通过调用read()和write()来实现的。

通过read()把数据从硬盘读取到内核缓冲区，再复制到用户缓冲区；然后再通过write()写入到socket缓冲区，最后写入网卡设备。

``` C
File.read(fileDesc, buf, len);
Socket.send(socket, buf, len);
```

整个过程发生了4次用户态和内核态的上下文切换和4次拷贝，具体流程如下：

1. 用户进程通过read()方法向操作系统发起调用，此时上下文从用户态转向内核态；
2. DMA控制器把数据从硬盘中拷贝到读缓冲区；
3. CPU把数据从读缓冲区数据拷贝到应用缓冲区，上下文从内核态转为用户态，read()返回；
4. 用户进程通过write()方法发起调用，上下文从用户态转为内核态；
5. CPU将应用缓冲区中数据拷贝到socket缓冲区；
6. DMA控制器把数据从socket缓冲区拷贝到网卡，上下文从内核态转为用户态，write()返回；

![传统的IO方式](https://gitee.com/Jesse3692/python_note/blob/master/asserts/imgs/io1.jpeg)

## 什么是用户态、内核态？上下文切换有是什么呢？

简单来说，用户空间指的就是用户进程的运行空间，内核空间就是内核的运行空间。

如果进程运行在内核空间就是内核态，运行在用户空间就是用户态。

为了安全起见，它们之间是相互隔离的，而在用户态和内核态之间的上下文切换也是比较耗时的。

## 什么是DMA拷贝？

因为对于一个IO操作而言，都是通过CPU发出对应的指令来完成。但是，相比CPU来说，IO的速度太慢了，CPU有大量的时间处于等待IO的状态。

因此就产生了DMA（Direct Memory Access）直接内存访问技术，本质上来说它就是一块主板上独立的芯片，通过它来进行内存和IO设备的数据传输，从而减少CPU的等待时间。

但是无论谁来拷贝，频繁的拷贝耗时也是对性能的影响。

> 参考资料
> [面试官：什么是mmap？](https://mp.weixin.qq.com/s/cg3NxVpSsHbTTrjnBNHG6A)
